/**
 * Formai Frontend Application
 * Modern JavaScript application with API integration, WebSocket support, and UI management
 */

class FormaiApp {
    constructor() {
        this.apiBaseUrl = this.getApiBaseUrl();
        this.websocket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.currentTheme = localStorage.getItem('theme') || 'light';
        this.activeModals = new Set();
        this.toastContainer = null;

        this.init();
    }

    /**
     * Initialize the application
     */
    async init() {
        try {
            this.setupTheme();
            this.setupToastContainer();
            this.bindEventListeners();
            this.setupWebSocket();
            this.loadInitialData();
            console.log('Formai app initialized successfully');
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.showToast('Failed to initialize application', 'error');
        }
    }

    /**
     * Get API base URL based on environment
     */
    getApiBaseUrl() {
        const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
        const host = window.location.hostname;
        const port = window.location.port || (protocol === 'https:' ? '443' : '80');
        return `${protocol}//${host}:${port}/api`;
    }

    // ===========================================
    // API INTEGRATION FUNCTIONS
    // ===========================================

    /**
     * Generic fetch wrapper with error handling
     */
    async apiRequest(endpoint, options = {}) {
        const config = {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        try {
            const response = await fetch(`${this.apiBaseUrl}${endpoint}`, config);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
            }

            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return await response.json();
            }

            return await response.text();
        } catch (error) {
            console.error(`API request failed for ${endpoint}:`, error);
            throw error;
        }
    }

    /**
     * Profile API methods
     */
    async getProfiles() {
        return await this.apiRequest('/profiles');
    }

    async createProfile(profileData) {
        return await this.apiRequest('/profiles', {
            method: 'POST',
            body: JSON.stringify(profileData)
        });
    }

    async updateProfile(profileId, profileData) {
        return await this.apiRequest(`/profiles/${profileId}`, {
            method: 'PUT',
            body: JSON.stringify(profileData)
        });
    }

    async deleteProfile(profileId) {
        return await this.apiRequest(`/profiles/${profileId}`, {
            method: 'DELETE'
        });
    }

    /**
     * URL API methods
     */
    async getUrls() {
        return await this.apiRequest('/urls');
    }

    async saveUrl(urlData) {
        return await this.apiRequest('/urls', {
            method: 'POST',
            body: JSON.stringify(urlData)
        });
    }

    async updateUrl(urlId, urlData) {
        return await this.apiRequest(`/urls/${urlId}`, {
            method: 'PUT',
            body: JSON.stringify(urlData)
        });
    }

    async deleteUrl(urlId) {
        return await this.apiRequest(`/urls/${urlId}`, {
            method: 'DELETE'
        });
    }

    /**
     * Settings API methods
     */
    async getSettings() {
        return await this.apiRequest('/settings');
    }

    async updateSettings(settingsData) {
        return await this.apiRequest('/settings', {
            method: 'PUT',
            body: JSON.stringify(settingsData)
        });
    }

    /**
     * Form submission API
     */
    async submitForm(formData) {
        return await this.apiRequest('/forms/submit', {
            method: 'POST',
            body: JSON.stringify(formData)
        });
    }

    // ===========================================
    // FORM HANDLING
    // ===========================================

    /**
     * Handle profile form submission
     */
    async handleProfileForm(form, isEdit = false) {
        const formData = new FormData(form);
        const profileData = Object.fromEntries(formData.entries());

        try {
            this.showToast('Saving profile...', 'info');

            let result;
            if (isEdit) {
                const profileId = form.dataset.profileId;
                result = await this.updateProfile(profileId, profileData);
            } else {
                result = await this.createProfile(profileData);
            }

            this.showToast('Profile saved successfully!', 'success');
            this.closeModal('profile-modal');
            this.refreshProfiles();

            return result;
        } catch (error) {
            this.showToast(`Failed to save profile: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * Handle URL form submission
     */
    async handleUrlForm(form, isEdit = false) {
        const formData = new FormData(form);
        const urlData = Object.fromEntries(formData.entries());

        try {
            this.showToast('Saving URL...', 'info');

            let result;
            if (isEdit) {
                const urlId = form.dataset.urlId;
                result = await this.updateUrl(urlId, urlData);
            } else {
                result = await this.saveUrl(urlData);
            }

            this.showToast('URL saved successfully!', 'success');
            this.closeModal('url-modal');
            this.refreshUrls();

            return result;
        } catch (error) {
            this.showToast(`Failed to save URL: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * Handle settings form submission
     */
    async handleSettingsForm(form) {
        const formData = new FormData(form);
        const settingsData = Object.fromEntries(formData.entries());

        try {
            this.showToast('Updating settings...', 'info');

            const result = await this.updateSettings(settingsData);

            this.showToast('Settings updated successfully!', 'success');

            return result;
        } catch (error) {
            this.showToast(`Failed to update settings: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * Validate form data
     */
    validateForm(form) {
        const requiredFields = form.querySelectorAll('[required]');
        let isValid = true;
        const errors = [];

        requiredFields.forEach(field => {
            if (!field.value.trim()) {
                isValid = false;
                errors.push(`${field.name || field.id} is required`);
                field.classList.add('error');
            } else {
                field.classList.remove('error');
            }
        });

        // Email validation
        const emailFields = form.querySelectorAll('input[type="email"]');
        emailFields.forEach(field => {
            if (field.value && !this.isValidEmail(field.value)) {
                isValid = false;
                errors.push('Please enter a valid email address');
                field.classList.add('error');
            }
        });

        // URL validation
        const urlFields = form.querySelectorAll('input[type="url"]');
        urlFields.forEach(field => {
            if (field.value && !this.isValidUrl(field.value)) {
                isValid = false;
                errors.push('Please enter a valid URL');
                field.classList.add('error');
            }
        });

        if (!isValid) {
            this.showToast(`Form validation failed: ${errors.join(', ')}`, 'error');
        }

        return isValid;
    }

    // ===========================================
    // WEBSOCKET CONNECTION
    // ===========================================

    /**
     * Setup WebSocket connection for real-time updates
     */
    setupWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname;
        const port = window.location.port || (protocol === 'wss:' ? '443' : '80');
        const wsUrl = `${protocol}//${host}:${port}/ws`;

        try {
            this.websocket = new WebSocket(wsUrl);

            this.websocket.onopen = () => {
                console.log('WebSocket connected');
                this.reconnectAttempts = 0;
                this.showToast('Connected to real-time updates', 'success', 2000);
            };

            this.websocket.onmessage = (event) => {
                this.handleWebSocketMessage(event);
            };

            this.websocket.onclose = () => {
                console.log('WebSocket disconnected');
                this.handleWebSocketReconnect();
            };

            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.showToast('Real-time connection error', 'error');
            };
        } catch (error) {
            console.error('Failed to setup WebSocket:', error);
        }
    }

    /**
     * Handle incoming WebSocket messages
     */
    handleWebSocketMessage(event) {
        try {
            const data = JSON.parse(event.data);

            switch (data.type) {
                case 'profile_updated':
                    this.refreshProfiles();
                    this.showToast('Profile updated', 'info');
                    break;

                case 'url_added':
                    this.refreshUrls();
                    this.showToast('New URL added', 'info');
                    break;

                case 'form_submitted':
                    this.showToast('Form submitted successfully', 'success');
                    break;

                case 'system_notification':
                    this.showToast(data.message, data.level || 'info');
                    break;

                default:
                    console.log('Unknown WebSocket message type:', data.type);
            }
        } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
        }
    }

    /**
     * Handle WebSocket reconnection
     */
    handleWebSocketReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

            console.log(`Attempting WebSocket reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`);

            setTimeout(() => {
                this.setupWebSocket();
            }, delay);
        } else {
            console.error('Max WebSocket reconnect attempts reached');
            this.showToast('Lost connection to real-time updates', 'warning');
        }
    }

    // ===========================================
    // THEME MANAGEMENT
    // ===========================================

    /**
     * Setup theme system
     */
    setupTheme() {
        // Use Tailwind's dark mode system
        document.documentElement.classList.toggle('dark', this.currentTheme === 'dark');

        // Update theme toggle button state
        const themeToggle = document.querySelector('#theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = this.currentTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            themeToggle.title = `Switch to ${this.currentTheme === 'dark' ? 'light' : 'dark'} mode`;
        }
    }

    /**
     * Toggle between light and dark themes
     */
    toggleTheme() {
        this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
        localStorage.setItem('theme', this.currentTheme);
        this.setupTheme();

        this.showToast(`Switched to ${this.currentTheme} mode`, 'info', 1500);

        // Emit theme change event
        window.dispatchEvent(new CustomEvent('themeChanged', {
            detail: { theme: this.currentTheme }
        }));
    }

    // ===========================================
    // NAVIGATION STATE MANAGEMENT
    // ===========================================

    /**
     * Navigate to a specific page/section
     */
    navigateTo(page, params = {}) {
        const navItems = document.querySelectorAll('.nav-item');
        const sections = document.querySelectorAll('.page-section');

        // Update navigation state
        navItems.forEach(item => {
            if (item.dataset.page === page) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });

        // Show/hide sections
        sections.forEach(section => {
            if (section.id === `${page}-section`) {
                section.classList.add('active');
                section.style.display = 'block';
            } else {
                section.classList.remove('active');
                section.style.display = 'none';
            }
        });

        // Update URL without page reload
        const url = new URL(window.location);
        url.searchParams.set('page', page);

        if (Object.keys(params).length > 0) {
            Object.entries(params).forEach(([key, value]) => {
                url.searchParams.set(key, value);
            });
        }

        window.history.pushState({ page, params }, '', url);

        // Load page-specific data
        this.loadPageData(page, params);
    }

    /**
     * Load data for specific page
     */
    async loadPageData(page, params = {}) {
        try {
            switch (page) {
                case 'dashboard':
                    if (window.dashboardManager) {
                        await window.dashboardManager.loadStats();
                    }
                    break;
                case 'profiles':
                    await this.refreshProfiles();
                    break;
                case 'urls':
                    await this.refreshUrls();
                    break;
                case 'settings':
                    await this.loadSettings();
                    break;
            }
        } catch (error) {
            console.error(`Failed to load data for page ${page}:`, error);
            this.showToast(`Failed to load ${page} data`, 'error');
        }
    }

    /**
     * Handle browser back/forward navigation
     */
    handlePopState(event) {
        const urlParams = new URLSearchParams(window.location.search);
        const page = urlParams.get('page') || 'home';
        const params = Object.fromEntries(urlParams.entries());
        delete params.page;

        this.navigateTo(page, params);
    }

    // ===========================================
    // MODAL/DIALOG HANDLING
    // ===========================================

    /**
     * Open a modal dialog
     */
    openModal(modalId, data = {}) {
        const modal = document.getElementById(modalId);
        if (!modal) {
            console.error(`Modal ${modalId} not found`);
            return;
        }

        // Populate modal with data if provided
        if (Object.keys(data).length > 0) {
            this.populateModal(modal, data);
        }

        modal.style.display = 'flex';
        modal.classList.add('active');
        this.activeModals.add(modalId);

        // Add escape key listener
        document.addEventListener('keydown', this.handleModalEscape.bind(this));

        // Focus first input
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
            setTimeout(() => firstInput.focus(), 100);
        }

        // Prevent body scrolling
        document.body.style.overflow = 'hidden';
    }

    /**
     * Close a modal dialog
     */
    closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        modal.style.display = 'none';
        modal.classList.remove('active');
        this.activeModals.delete(modalId);

        // Remove escape key listener if no modals are open
        if (this.activeModals.size === 0) {
            document.removeEventListener('keydown', this.handleModalEscape.bind(this));
            document.body.style.overflow = '';
        }

        // Clear form if present
        const form = modal.querySelector('form');
        if (form) {
            form.reset();
            form.querySelectorAll('.error').forEach(field => {
                field.classList.remove('error');
            });
        }
    }

    /**
     * Handle escape key press in modals
     */
    handleModalEscape(event) {
        if (event.key === 'Escape' && this.activeModals.size > 0) {
            const lastModal = Array.from(this.activeModals).pop();
            this.closeModal(lastModal);
        }
    }

    /**
     * Populate modal with data
     */
    populateModal(modal, data) {
        Object.entries(data).forEach(([key, value]) => {
            const field = modal.querySelector(`[name="${key}"]`);
            if (field) {
                if (field.type === 'checkbox') {
                    field.checked = Boolean(value);
                } else {
                    field.value = value;
                }
            }
        });
    }

    // ===========================================
    // TOAST NOTIFICATIONS
    // ===========================================

    /**
     * Setup toast notification container
     */
    setupToastContainer() {
        this.toastContainer = document.getElementById('toast-container');
        if (!this.toastContainer) {
            this.toastContainer = document.createElement('div');
            this.toastContainer.id = 'toast-container';
            this.toastContainer.className = 'toast-container';
            document.body.appendChild(this.toastContainer);
        }
    }

    /**
     * Show toast notification
     */
    showToast(message, type = 'info', duration = 4000) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;

        const icon = this.getToastIcon(type);
        toast.innerHTML = `
            <span class="toast-icon">${icon}</span>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        this.toastContainer.appendChild(toast);

        // Animate in
        setTimeout(() => toast.classList.add('show'), 100);

        // Auto remove
        if (duration > 0) {
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        return toast;
    }

    /**
     * Get icon for toast type
     */
    getToastIcon(type) {
        const icons = {
            success: '‚úÖ',
            error: '‚ùå',
            warning: '‚ö†Ô∏è',
            info: '‚ÑπÔ∏è'
        };
        return icons[type] || icons.info;
    }

    // ===========================================
    // DATA REFRESH METHODS
    // ===========================================

    /**
     * Refresh profiles data
     */
    async refreshProfiles() {
        try {
            const profiles = await this.getProfiles();
            this.updateProfilesUI(profiles);
        } catch (error) {
            console.error('Failed to refresh profiles:', error);
            this.showToast('Failed to load profiles', 'error');
        }
    }

    /**
     * Refresh URLs data
     */
    async refreshUrls() {
        try {
            const urls = await this.getUrls();
            this.updateUrlsUI(urls);
        } catch (error) {
            console.error('Failed to refresh URLs:', error);
            this.showToast('Failed to load URLs', 'error');
        }
    }

    /**
     * Load settings data
     */
    async loadSettings() {
        try {
            const settings = await this.getSettings();
            this.updateSettingsUI(settings);
        } catch (error) {
            console.error('Failed to load settings:', error);
            this.showToast('Failed to load settings', 'error');
        }
    }

    /**
     * Load initial application data
     */
    async loadInitialData() {
        const urlParams = new URLSearchParams(window.location.search);
        const initialPage = urlParams.get('page') || 'dashboard';

        this.navigateTo(initialPage);
    }

    // ===========================================
    // UI UPDATE METHODS
    // ===========================================

    /**
     * Update profiles UI
     */
    updateProfilesUI(profiles) {
        const container = document.getElementById('profiles-grid');
        if (!container) return;

        if (profiles.length === 0) {
            container.innerHTML = `
                <div class="col-span-full text-center py-8">
                    <p class="text-gray-500 dark:text-gray-400">No profiles found</p>
                </div>
            `;
            return;
        }

        container.innerHTML = profiles.map(profile => {
            const data = profile.data || {};
            const createdDate = new Date(profile.created_at).toLocaleDateString();

            return `
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 hover:shadow-md transition-shadow" data-id="${profile.id}">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-900 dark:text-white">${profile.name || profile.id}</h3>
                        <div class="flex gap-2">
                            <button onclick="app.editProfile('${profile.id}')" class="text-blue-600 hover:text-blue-700 p-2 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button onclick="app.deleteProfileConfirm('${profile.id}')" class="text-red-600 hover:text-red-700 p-2 hover:bg-red-50 dark:hover:bg-red-900/20 rounded">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                        ${data.firstName && data.lastName ? `<p><span class="font-medium">Name:</span> ${data.firstName} ${data.lastName}</p>` : ''}
                        ${data.email ? `<p><span class="font-medium">Email:</span> ${data.email}</p>` : ''}
                        ${data.phone ? `<p><span class="font-medium">Phone:</span> ${data.phone}</p>` : ''}
                        ${data.address ? `<p><span class="font-medium">Address:</span> ${data.address}${data.city ? `, ${data.city}` : ''}</p>` : ''}
                        <p><span class="font-medium">Created:</span> ${createdDate}</p>
                    </div>
                    <div class="mt-4">
                        <button onclick="app.useProfile('${profile.id}')" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg font-medium transition-colors">
                            Use This Profile
                        </button>
                    </div>
                </div>
            `;
        }).join('') + `
            <!-- Create New Profile Card -->
            <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg border-2 border-dashed border-gray-300 dark:border-gray-600 p-6 flex flex-col items-center justify-center hover:border-blue-500 transition-colors cursor-pointer" onclick="app.showCreateProfileModal()">
                <i class="fas fa-plus text-4xl text-gray-400 dark:text-gray-500 mb-4"></i>
                <h3 class="text-lg font-medium text-gray-700 dark:text-gray-300 mb-2">Create New Profile</h3>
                <p class="text-sm text-gray-500 dark:text-gray-400 text-center">Add personal information for automated form filling</p>
            </div>
        `;
    }

    /**
     * Update URLs UI
     */
    updateUrlsUI(urls) {
        const container = document.getElementById('urls-list');
        if (!container) return;

        if (urls.length === 0) {
            container.innerHTML = `
                <div class="text-center py-8">
                    <p class="text-gray-500 dark:text-gray-400">No URLs found</p>
                </div>
            `;
            return;
        }

        container.innerHTML = urls.map(url => `
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6" data-id="${url.id}">
                <div class="flex justify-between items-start mb-4">
                    <div class="flex-1">
                        <div class="flex items-center gap-3 mb-2">
                            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">${url.title || url.url}</h3>
                            <span class="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 text-xs rounded-full">${url.group || 'General'}</span>
                            <span class="px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 text-xs rounded-full">${url.status || 'Active'}</span>
                        </div>
                        <p class="text-gray-600 dark:text-gray-400 text-sm mb-3">${url.description || 'No description available'}</p>
                        <div class="flex items-center gap-4 text-xs text-gray-500 dark:text-gray-400">
                            <span class="flex items-center gap-1">
                                <i class="fas fa-link"></i>
                                <a href="${url.url}" target="_blank" class="hover:text-blue-600 dark:hover:text-blue-400">${new URL(url.url).hostname}</a>
                            </span>
                        </div>
                    </div>
                    <div class="flex gap-2 ml-4">
                        <button onclick="app.runAutomation('${url.id}')" class="text-green-600 hover:text-green-700 p-2 hover:bg-green-50 dark:hover:bg-green-900/20 rounded" title="Run Automation">
                            <i class="fas fa-play"></i>
                        </button>
                        <button onclick="app.editUrl('${url.id}')" class="text-blue-600 hover:text-blue-700 p-2 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded" title="Edit URL">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button onclick="app.deleteUrlConfirm('${url.id}')" class="text-red-600 hover:text-red-700 p-2 hover:bg-red-50 dark:hover:bg-red-900/20 rounded" title="Delete URL">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            </div>
        `).join('') + `
            <!-- Add URL Card -->
            <div class="bg-gray-50 dark:bg-gray-800/50 rounded-lg shadow-sm border-2 border-dashed border-gray-300 dark:border-gray-600 p-8 text-center hover:border-green-500 hover:bg-green-50/50 dark:hover:bg-green-900/10 transition-all cursor-pointer group" onclick="app.showCreateUrlModal()">
                <i class="fas fa-plus text-3xl text-gray-400 group-hover:text-green-500 mb-3 transition-colors"></i>
                <p class="text-gray-600 dark:text-gray-400 font-medium group-hover:text-green-600 dark:group-hover:text-green-400">Add New URL</p>
                <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">Add a target URL for form automation</p>
            </div>
        `;
    }

    /**
     * Update settings UI
     */
    updateSettingsUI(settings) {
        Object.entries(settings).forEach(([key, value]) => {
            const field = document.querySelector(`[name="${key}"]`);
            if (field) {
                if (field.type === 'checkbox') {
                    field.checked = Boolean(value);
                } else {
                    field.value = value;
                }
            }
        });
    }

    // ===========================================
    // ACTION METHODS
    // ===========================================

    /**
     * Edit profile
     */
    async editProfile(profileId) {
        try {
            const profile = await this.apiRequest(`/profiles/${profileId}`);
            this.openModal('profile-modal', profile);

            const form = document.getElementById('profile-form');
            if (form) {
                form.dataset.profileId = profileId;
            }
        } catch (error) {
            this.showToast('Failed to load profile for editing', 'error');
        }
    }

    /**
     * Delete profile with confirmation
     */
    deleteProfileConfirm(profileId) {
        if (confirm('Are you sure you want to delete this profile?')) {
            this.deleteProfileAction(profileId);
        }
    }

    /**
     * Delete profile action
     */
    async deleteProfileAction(profileId) {
        try {
            await this.deleteProfile(profileId);
            this.showToast('Profile deleted successfully', 'success');
            this.refreshProfiles();
        } catch (error) {
            this.showToast('Failed to delete profile', 'error');
        }
    }

    /**
     * Use profile for automation
     */
    useProfile(profileId) {
        // Store the selected profile
        localStorage.setItem('selectedProfileId', profileId);
        this.showToast('Profile selected for automation', 'success');

        // Navigate to URL selection or automation page
        this.navigateTo('urls');
    }

    /**
     * Show create profile modal
     */
    showCreateProfileModal() {
        this.openModal('profile-modal');
    }

    /**
     * Edit URL
     */
    async editUrl(urlId) {
        try {
            const url = await this.apiRequest(`/urls/${urlId}`);
            this.openModal('url-modal', url);

            const form = document.getElementById('url-form');
            if (form) {
                form.dataset.urlId = urlId;
            }
        } catch (error) {
            this.showToast('Failed to load URL for editing', 'error');
        }
    }

    /**
     * Delete URL with confirmation
     */
    deleteUrlConfirm(urlId) {
        if (confirm('Are you sure you want to delete this URL?')) {
            this.deleteUrlAction(urlId);
        }
    }

    /**
     * Delete URL action
     */
    async deleteUrlAction(urlId) {
        try {
            await this.deleteUrl(urlId);
            this.showToast('URL deleted successfully', 'success');
            this.refreshUrls();
        } catch (error) {
            this.showToast('Failed to delete URL', 'error');
        }
    }

    /**
     * Show create URL modal
     */
    showCreateUrlModal() {
        this.openModal('url-modal');
    }

    /**
     * Run automation for a URL
     */
    async runAutomation(urlId) {
        const selectedProfileId = localStorage.getItem('selectedProfileId');

        if (!selectedProfileId) {
            this.showToast('Please select a profile first', 'warning');
            this.navigateTo('profiles');
            return;
        }

        try {
            this.showToast('Starting automation...', 'info');

            const response = await this.apiRequest('/run-automation', {
                method: 'POST',
                body: JSON.stringify({
                    profile_id: selectedProfileId,
                    url_id: urlId
                })
            });

            this.showToast('Automation started successfully', 'success');
        } catch (error) {
            console.error('Automation failed:', error);
            this.showToast('Failed to start automation', 'error');
        }
    }

    // ===========================================
    // UTILITY METHODS
    // ===========================================

    /**
     * Validate email format
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    /**
     * Validate URL format
     */
    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }

    /**
     * Debounce function calls
     */
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    /**
     * Format date for display
     */
    formatDate(dateString) {
        return new Date(dateString).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    // ===========================================
    // EVENT LISTENERS SETUP
    // ===========================================

    /**
     * Bind all event listeners
     */
    bindEventListeners() {
        // Theme toggle
        document.addEventListener('click', (e) => {
            if (e.target.matches('#theme-toggle')) {
                this.toggleTheme();
            }
        });

        // Navigation
        document.addEventListener('click', (e) => {
            if (e.target.matches('.nav-item')) {
                const page = e.target.dataset.page;
                if (page) {
                    this.navigateTo(page);
                }
            }
        });

        // Modal handling
        document.addEventListener('click', (e) => {
            // Open modals
            if (e.target.matches('[data-modal]')) {
                this.openModal(e.target.dataset.modal);
            }

            // Close modals
            if (e.target.matches('.modal-close, .modal-overlay')) {
                const modal = e.target.closest('.modal');
                if (modal) {
                    this.closeModal(modal.id);
                }
            }
        });

        // Form submissions
        document.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (!this.validateForm(e.target)) {
                return;
            }

            const form = e.target;
            const formType = form.dataset.type;
            const isEdit = form.dataset.profileId || form.dataset.urlId;

            try {
                switch (formType) {
                    case 'profile':
                        await this.handleProfileForm(form, isEdit);
                        break;
                    case 'url':
                        await this.handleUrlForm(form, isEdit);
                        break;
                    case 'settings':
                        await this.handleSettingsForm(form);
                        break;
                    default:
                        console.warn('Unknown form type:', formType);
                }
            } catch (error) {
                console.error('Form submission error:', error);
            }
        });

        // Browser navigation
        window.addEventListener('popstate', this.handlePopState.bind(this));

        // Connection status
        window.addEventListener('online', () => {
            this.showToast('Connection restored', 'success');
            if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                this.setupWebSocket();
            }
        });

        window.addEventListener('offline', () => {
            this.showToast('Connection lost', 'warning');
        });
    }
}

// ===========================================
// APPLICATION INITIALIZATION
// ===========================================

// Initialize app when DOM is ready
let app;

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        app = new FormaiApp();
        window.app = app; // Make globally available
    });
} else {
    app = new FormaiApp();
    window.app = app; // Make globally available
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FormaiApp;
}